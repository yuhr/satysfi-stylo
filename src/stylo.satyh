@require: gr
@require: color
@require: base/int
@require: base/float
@require: base/length
@require: base/list-ext
@require: base/debug
@require: base/string
@require: base/option-ext
@require: base/int
@require: base/fn

type bezier = point * (point * point * point)
type position = Scale of float | Length of length
type angle = Radians of float | Degrees of float

module Stylo : sig

  type stylo-pre-path
  type stylo-path

  % type stroke-width
  % type stroke-color
  % type fill-color
  % type text-options
  % type path-options
  % type render-options
  % type path-context
  % type render-context
  % type context

  val start: point -> stylo-pre-path
  val start-with-tangent: point -> point -> stylo-pre-path
  val line-to: point -> stylo-pre-path -> stylo-pre-path
  val bezier-to: point * point * point -> stylo-pre-path -> stylo-pre-path
  val terminate: stylo-pre-path -> stylo-path
  val close: stylo-pre-path -> stylo-path
  val close-with-line: stylo-pre-path -> stylo-path
  val close-with-bezier: point * point -> stylo-pre-path -> stylo-path
  val is-closed: stylo-path -> bool

  type footage

  %val solid-with-arrowhead: stylo-pre-path -> stylo-path
  val translate-footage: point -> footage -> footage
  val shift-point: point -> point -> point
  val unshift-point: point -> point -> point
  val rotate-point: float -> point -> point
  val rotate-point-around: point -> float -> point -> point
  val scale-point: float -> point -> point
  val scale-point-around: point -> float -> point -> point
  val centerpoint: point * point -> point

  val split-at: position -> stylo-path -> stylo-path * stylo-path
  val split-into-at: position -> float -> stylo-path -> stylo-path list
  val split-incr-at: position -> position -> stylo-path -> stylo-path list

  val length-of-bezier: bezier -> length
  val length-of-path: stylo-path -> length
  val distance: point -> point -> length
  val line-to-by: point -> length -> stylo-pre-path -> stylo-pre-path
  val line-for-by: point -> length -> stylo-pre-path -> stylo-pre-path

  val arc-with-around: point -> angle -> stylo-pre-path -> stylo-pre-path
  val arc-to-around: point -> point -> stylo-pre-path -> stylo-pre-path
  val arc-to-through: point -> point -> stylo-pre-path -> stylo-pre-path
  val arc-aside: length -> angle -> stylo-pre-path -> stylo-pre-path
  %val arc-to-for: point -> point -> stylo-pre-path -> stylo-pre-path

  direct \stylo: [length * length * length; footage list] inline-cmd

  val solid: stylo-path -> footage
  val label-at: point -> inline-text -> footage

end = struct

  % backup indentifiers for internals
  type internal-path = path
  type internal-pre-path = pre-path
  let internal-start-path = start-path
  let internal-line-to = line-to
  let internal-bezier-to = bezier-to
  let internal-terminate-path = terminate-path
  let internal-close-with-line = close-with-line
  let internal-close-with-bezier = close-with-bezier
  let internal-stroke = stroke

  % TODO: refactor path repres
  type path-element = LineTo of point | BezierTo of point * point * point
  type path-closing = LineToStart | BezierToStart of point * point

  % prefixed because of #81 (https://github.com/gfngfn/SATySFi/issues/81)
  type stylo-pre-path = point option * point * path-element list
  type stylo-path = point * path-element list * path-closing option

  type composite-path = stylo-path list
  type footage = context -> graphics

  % type stroke-width = length
  % type stroke-color = color
  % type fill-color = color
  % type text-options = context
  % type path-options = stroke-width * stroke-color * fill-color
  % type render-options = text-options * path-options
  % type path-context = stylo-path list * stylo-pre-path
  % type render-context = path-context
  % type context = render-context list * render-options


  % utilities
  let half-length l = l /' 2.0cm |> Length.of-cm

  let radians-to-degrees t = t /. Float.pi *. 180.0
  let degrees-to-radians t = t *. Float.pi /. 180.0

  let (+'') (ax, ay) (bx, by) = (ax +' bx, ay +' by)
  let (-'') (ax, ay) (bx, by) = (ax -' bx, ay -' by)
  let (*'.) (ax, ay) b = (ax *' b, ay *' b)
  let (/'.) (ax, ay) b = (ax /' (b |> Length.of-cm) |> Length.of-cm, ay /' (b |> Length.of-cm) |> Length.of-cm)

  type polarity = Negative | Zero | Positive

  let sign-of-int i = if i == 0 then 0 else i / Int.abs i
  let sign-of-float f = if Float.is-zero f then 0.0 else f /. Float.abs f
  let polarity-of-float f = open Float in
    if is-zero f then Zero
    else if f < 0.0 then Negative
    else Positive

  let-rec range i = open Int in
    let-rec range-rec j l =
      if i <= j
      then l
      else range-rec (j + 1) (j :: l)
    in range-rec 0 []

  let point-length-to-float (vx, vy) =
    (vx /' 1.0cm, vy /' 1.0cm)
  let point-float-to-length (vx, vy) =
    (vx |> Length.of-cm, vy |> Length.of-cm)

  let segment ((px, py), (qx, qy)) =
    (px -' qx, py -' qy)
  let length seg =
    let (x, y) = seg |> point-length-to-float in
    ((x *. x) +. (y *. y)) |> Float.sqrt |> Length.of-cm |> Length.abs
  let lerp t (s, e) =
    let (sx, sy) = s in
    let (dx, dy) = segment (e, s) *'. t in
    (sx +' dx, sy +' dy)
  let centerpoint (s, e) = lerp 0.5 (s, e)
  let distance v0 v1 = segment (v0, v1) |> length
  let normalize v = v /'. (length v /' 1cm) |> point-length-to-float

  let is-zero-distance-between p1 p2 = open Float in
    (distance p1 p2 /' 1cm) < 0.0000000000000001

  let dot-product (v0x, v0y) (v1x, v1y) = (v0x *. v1x) +. (v0y *. v1y)
  let cross-product (v0x, v0y) (v1x, v1y) = (v0x *. v1y) -. (v0y *. v1x)
  let dot-product-lines s0 s1 =
    let n0 = segment s0 |> point-length-to-float in
    let n1 = segment s1 |> point-length-to-float in
    dot-product n0 n1
  let cross-product-lines s0 s1 =
    let n0 = segment s0 |> point-length-to-float in
    let n1 = segment s1 |> point-length-to-float in
    cross-product n0 n1
  let dot-product-normalized-lines-of s0 s1 =
    let n0 = segment s0 |> normalize in
    let n1 = segment s1 |> normalize in
    dot-product n0 n1
  let cross-product-normalized-lines-of s0 s1 =
    let n0 = segment s0 |> normalize in
    let n1 = segment s1 |> normalize in
    cross-product n0 n1


  let convert-path-to-internal stylo-path =
    let (start, elements, closing) = stylo-path in
    let stylo-pre-path = elements |> List.fold-left (fun stylo-pre-path element -> (
      match element with
      | LineTo e -> internal-line-to e stylo-pre-path
      | BezierTo (cp1, cp2, e) -> internal-bezier-to cp1 cp2 e stylo-pre-path
    )) (internal-start-path start) in
    match closing with
    | Some closing -> (match closing with
      | LineToStart -> internal-close-with-line stylo-pre-path
      | BezierToStart (cp1, cp2) -> internal-close-with-bezier cp1 cp2 stylo-pre-path)
    | None -> internal-terminate-path stylo-pre-path

  let convert-composite-path-to-internal composite-path =
    composite-path
    |> List.map convert-path-to-internal
    |> List.map Option.some
    |> List.fold-left (fun prev curr -> (
      match prev with
      | None -> curr
      | Some prev -> Some (unite-path prev (Option.unwrap curr))
    )) None
    |> Option.unwrap

  type linear-path = Path of stylo-path | PrePath of stylo-pre-path

  let last-element-of-linear-path p = match p with
    | PrePath (_, _, elements) -> List.head elements
    | Path (starting, elements, closing) -> (match closing with
      | None -> List.last elements
      | Some closing -> (match closing with
        | LineToStart -> Some (LineTo starting)
        | BezierToStart (cp1, cp2) -> Some (BezierTo (cp1, cp2, starting))))

  let last-point-of-path-element e = match e with
    | LineTo p -> p
    | BezierTo (_, _, p) -> p

  let first-point-of-linear-path p = match p with
    | PrePath (_, p, _) -> p
    | Path (p, _, _) -> p

  let last-point-of-linear-path p =
    let last-element = last-element-of-linear-path p in
    match last-element with
    | None -> first-point-of-linear-path p
    | Some element -> last-point-of-path-element element

  let start p = (None, p, List.nil)

  let start-with-tangent t p = (Some t, p, List.nil)

  let line-to e (pre, start, elements) =
    (pre, start, LineTo e :: elements)

  let bezier-to (cp1, cp2, e) (pre, start, elements) =
    (pre, start, BezierTo (cp1, cp2, e) :: elements)

  let terminate (_, start, elements) =
    (start, List.reverse elements, None)

  let close (_, first, elements) =
    match elements with
    | [] -> (first, [], None)
    | last-element :: rest-elements ->
      let last = last-point-of-path-element last-element in
      if distance first last <' 0.00001cm
      then match last-element with
      | LineTo _ ->
        (first, List.reverse rest-elements, Some (LineToStart))
      | BezierTo (cp1, cp2, _) ->
        (first, List.reverse rest-elements, Some (BezierToStart (cp1, cp2)))
      else
        (first, List.reverse elements, None)

  let close-with-line (_, start, elements) =
    (start, List.reverse elements, Some (LineToStart))

  let close-with-bezier cps (_, start, elements) =
    (start, List.reverse elements, Some (BezierToStart cps))


  let is-closed (_, _, closing) = match closing with
    | None -> false
    | Some _ -> true


  let current-point (pre, start, elements) =
    match elements with
    | [] -> start
    | first :: _ -> (match first with
      | LineTo p -> p
      | BezierTo (_, _, p) -> p)

  let current-tangent (pre, start, elements) =
    match elements with
    | [] -> (match pre with
      | None -> (start, start)
      | Some pre -> (start, pre))
    | first :: rest -> (match first with
      | LineTo p1 -> (match rest with
        | [] -> (p1, start)
        | second :: _ -> (match second with
          | LineTo p2 -> (p1, p2)
          | BezierTo (_, _, p2) -> (p1, p2)))
      | BezierTo (_, cp2, p) -> (p, cp2))

  let stroke l c p = internal-stroke l c (convert-path-to-internal p)


  let length-of-line (s, e) = distance s e

  let split-line-at t (s, e) =
    let x = lerp t (s, e) in
    let l1 = (s, x) in
    let l2 = (x, e) in
    (l1, l2)

  let split-line-at-length l (s, e) =
    let total-length = segment (s, e) |> length in
    let t = l /' total-length in
    split-line-at t (s, e)

  let length-of-bezier-lines (s, (cp1, cp2, e)) =
    let l1 = segment (s, cp1) |> length in
    let l2 = segment (cp1, cp2) |> length in
    let l3 = segment (cp2, e) |> length in
    l1 +' l2 +' l3

  let opposed-control-points (s, (cp1, cp2, e)) =
    let s1 = sign-of-float (cross-product-lines (s, e) (s, cp1)) in
    let s2 = sign-of-float (cross-product-lines (e, s) (e, cp2)) in
    Float.equal s1 s2

  let split-bezier-at-in-scale t (s, (cp1, cp2, e)) =
    let split = lerp t in
    let l1 = (s, cp1) in
    let l2 = (cp1, cp2) in
    let l3 = (cp2, e) in
    let s1 = split l1 in
    let s2 = split l2 in
    let s3 = split l3 in
    let l12 = (s1, s2) in
    let l23 = (s2, s3) in
    let s12 = split l12 in
    let s23 = split l23 in
    let lt = (s12, s23) in
    let st = split lt in
    let b1 = (s, (s1, s12, st)) in
    let b2 = (st, (s23, s3, e)) in
    (b1, b2)

  let-rec length-of-bezier b = let (s, (cp1, cp2, e)) = b in
    let (b1, b2) = split-bezier-at-in-scale 0.5 b in
    if opposed-control-points b
    then length-of-bezier b1 +' length-of-bezier b2
    else
      let (bc, _) = b2 in
      let lc = centerpoint (s, e) in
      if distance bc lc <' 0.0001cm % FIXME: refactor some precise way
      then length-of-line (s, e)
      else length-of-bezier b1 +' length-of-bezier b2

  let length-of-path-element s element =
    match element with
    | LineTo e -> length-of-line (s, e)
    | BezierTo b -> length-of-bezier (s, b)

  let length-of-path-closing s closing e =
    match closing with
    | Some closing -> (match closing with
      | LineToStart -> length-of-line (s, e)
      | BezierToStart (cp1, cp2) -> length-of-bezier (s, (cp1, cp2, e)))
    | None -> 0cm

  let length-of-path-elements s elements =
    match elements with
    | [] -> 0cm
    | _ ->
      let (l, _) = elements |> List.fold-left (fun (l, prev-point) element ->
        (l +' length-of-path-element prev-point element, last-point-of-path-element element)
      ) (0cm, s) in l

  let last-point-of-path-elements s elements =
    match elements with
    | [] -> s
    | _ -> (match List.last elements with
      | Some (LineTo e) -> e
      | Some (BezierTo (_, _, e)) -> e
      | None -> s)

  let show-length x = x /' 1cm |> show-float

  let split-bezier-at-in-length l b = let (s, (cp1, cp2, e)) = b in
    let-rec bisect t step =
      let (former, latter) = split-bezier-at-in-scale t b in
      let approx = length-of-bezier former in
      if Length.abs (l -' approx) <' 0.00001cm
      then t
      else if l <' approx
      then bisect (t -. (Float.pow (Float.of-int <| step + 2) 0.5)) (step + 1)
      else bisect (t +. (Float.pow (Float.of-int <| step + 2) 0.5)) (step + 1) in
    let t = bisect 0.5 0 in
    split-bezier-at-in-scale t b

  let split-bezier-at p = match p with
  | Scale p -> split-bezier-at-in-scale p
  | Length p -> split-bezier-at-in-length p

  let length-of-path p =
    let (start-point, elements, closing) = p in
    let length-of-elements = length-of-path-elements start-point elements in
    let last-point = last-point-of-path-elements start-point elements in
    length-of-elements +' length-of-path-closing last-point closing start-point

  let mod-length l1 l2 = l1 -' l2 *' (l1 /' l2 |> Float.floor)
  let (++) l1 l2 = List.append l1 l2

  let split-at-in-length l p =
    let total-length = length-of-path p in
    let l = if total-length <' l then mod-length l total-length else l in
    let (start-point, elements, closing) = p in
    match elements with
    | [] -> (p, p) % FIXME: in case when closing is bezier
    | _ ->
      let folded = elements |> List.fold-lefti (fun i folded element -> (
        let (to-split, acc, prev-point) = folded in
        match to-split with
        | Some _ -> folded
        | None ->
          let length-of-element = length-of-path-element prev-point element in
          let curr-point = last-point-of-path-element element in
          if acc +' length-of-element <' l
          then
            (None, acc +' length-of-element, curr-point)
          else
            let (former, latter) = (List.take (i - 1) elements, List.drop i elements) in
            (Some (l -' acc, element, former, latter), acc, prev-point)
      )) (None, 0cm, start-point) in
        let (Some to-split, _, s) = folded in
        let (local-length, element, former, latter) = to-split in
        match element with
        | LineTo e ->
          let line = (s, e) in
          let (_, (x, e)) = split-line-at-length local-length line in
          let former = (start-point, former ++ [LineTo x], None) in
          let latter = (x, [LineTo e] ++ latter, closing) in
          (former, latter)
        | BezierTo b ->
          let bezier = (s, b) in
          let ((_, b1b), (b2s, b2b)) = split-bezier-at-in-length local-length bezier in
          let former = (start-point, former ++ [BezierTo b1b], None) in
          let latter = (b2s, [BezierTo b2b] ++ latter, closing) in
          (former, latter)

  let split-at-in-scale t p =
    let total-length = length-of-path p in
    let l = total-length *' t in
    split-at-in-length l p

  let split-at p = match p with
  | Scale p -> split-at-in-scale p
  | Length p -> split-at-in-length p

  let split-incr-at t i p =
    let total-length = length-of-path p in
    let t = match t with
    | Scale t -> total-length *' t
    | Length t -> t in
    let i = match i with
    | Scale i -> total-length *' i
    | Length i -> i in
    let-rec rec l p r =
      let remained-length = length-of-path p in
      if remained-length <' l
      then r
      else let (subpath, p) = split-at-in-length l p in
        rec (l +' i) p (r ++ [subpath])
    in rec i p []

  let split-into-at t d p =
    let i = 1.0 /. d in
    split-incr-at t (Scale i) p

  % let terminate-with-arrowhead p =
  %   let s = current-point p in
  %   let (tx, ty) = current-tangent p |> segment in
  %   let a = atan2 (ty /' 1cm) (tx /' 1cm) in
  %   let arrowhead-left-side =
  %     start-path (0cm, 0cm)
  %     |> bezier-to ((-1pt, 0pt), (-5pt, 1pt), (-6pt, 2pt))
  %     |> terminate in
  %   let arrowhead-right-side =
  %     start-path (0cm, 0cm)
  %     |> bezier-to ((-1pt, 0pt), (-5pt, -1pt), (-6pt, -2pt))
  %     |> terminate in
  %   unite-path arrowhead-left-side arrowhead-right-side
  %   |> rotate-path (0cm, 0cm) a
  %   |> shift-path s
  %   |> unite-path (p |> terminate)

  let shift-point (ox, oy) (x, y) = (x +' ox, y +' oy)
  let unshift-point (ox, oy) (x, y) = (x -' ox, y -' oy)

  let rotate-point t (x, y) =
    ((x *' cos t) -' (y *' sin t),
    (x *' sin t) +' (y *' cos t))
  let rotate-point-around (cx, cy) t (x, y) =
    (x, y)
      |> shift-point (0cm -' cx, 0cm -' cy)
      |> rotate-point t
      |> shift-point (cx, cy)

  let scale-point s (x, y) = (x *' s, y *' s)
  let scale-point-around (cx, cy) s (x, y) =
    (x, y)
      |> shift-point (0cm -' cx, 0cm -' cy)
      |> scale-point s
      |> shift-point (cx, cy)

  let line-to-by t l p =
    let s = current-point p in
    let (sx, sy) = s in
    let (tx, ty) = t in
    let d = distance t s in
    let r = l /' d in
    let (tx, ty) = segment (t, s) in
    let a = (sx +' (tx *' r), sy +' (ty *' r)) in
    p |> line-to a

  let line-for-by f l p =
    let s = current-point p in
    line-to-by (shift-point f s) l p

  let bool-equal b0 b1 =
    if b0
    then if b1 then true else false
    else if b1 then false else true

  let arc-with-around-in-radians c t p =
    let half-pi = Float.pi *. 0.5000000000000001 in
    let-rec arc-with-around-in-radians-rec c t p d =
      let s = current-point p in
      let (sx, sy) = s in
      let (cx, cy) = c in
      let angle-to-c = atan2 ((sy -' cy) /' 1cm) ((sx -' cx) /' 1cm) in
      let id x = x in
      let p =
        if d <> 0
        then arc-with-around-in-radians-rec c (half-pi *. (float (sign-of-int d))) p (d - (sign-of-int d))
        else p in
      let radius = distance s c in
      let control-point-length t = (4.0 /. 3.0) *. tan (t /. 4.0) in
      let k = control-point-length t in
      let [p0; p1; p2; p3] = [
        (radius, 0cm);
        (radius, radius *' k);
        (radius *' (cos t +. k *. sin t), radius *' (sin t -. k *. cos t));
        (radius *' cos t, radius *' sin t);
      ]
        |> List.map (rotate-point (half-pi *. (float d)))
        |> List.map (shift-point (sx -' radius, sy))
        |> List.map (rotate-point-around s angle-to-c) in
      p |> bezier-to (p1, p2, p3) in
    open Float in
    let d = t /. half-pi |> Float.floor |> Float.to-int in
    let t = if d <> 0 then t -. (half-pi *. (float d)) else t in
    arc-with-around-in-radians-rec c t p d

  let arc-with-around-in-degrees c t p =
    arc-with-around-in-radians c (degrees-to-radians t) p

  let arc-with-around c t = match t with
  | Radians t -> arc-with-around-in-radians c t
  | Degrees t -> arc-with-around-in-degrees c t

  let radians-ccw-of l1 l2 =
    let d = dot-product-normalized-lines-of l1 l2 in
    let c = cross-product-normalized-lines-of l1 l2 in
    let l = segment l1 |> length |> Length.to-float in
    let h = c /. l in
    Float.atan2 h d

  let arc-to-around c e p =
    let s = current-point p in
    let t =
      if is-zero-distance-between s e then Degrees 360.0 else
      let l1 = (s, c) in
      let l2 = (e, c) in
      Radians (radians-ccw-of l1 l2)
    in
    arc-with-around c t p


  let arc-to-through n i p =
    open Float in
    let s = current-point p in
    let va = s in
    let vb = i in
    let vc = n in
    let a = (distance vb vc) /' 1cm in
    let b = (distance vc va) /' 1cm in
    let c = (distance va vb) /' 1cm in
    if c +. a -. b < 0.000000000000001
    then line-to n p
    else
      let aa = a *. a in
      let bb = b *. b in
      let cc = c *. c in
      let d = aa *. (bb +. cc -. aa) in
      let e = bb *. (cc +. aa -. bb) in
      let f = cc *. (aa +. bb -. cc) in
      let o = ((va *'. d) +'' (vb *'. e) +'' (vc *'. f)) /'. (d +. e +. f) in
      let t = dot-product-normalized-lines-of (s, o) (n, o) |> acos in
      let i-is-left = cross-product-normalized-lines-of (n, s) (i, s) > 0.0 in
      let o-is-left = cross-product-normalized-lines-of (n, s) (o, s) > 0.0 in
      let t = if bool-equal i-is-left o-is-left then Float.pi *. 2.0 -. t else t in
      let t = if i-is-left then t |> Float.neg else t in
      arc-with-around-in-radians o t p

  % draws an arc turn-aroundingly, with radius `r`, with angle `t`
  let arc-aside-in-radians r t p =
    let (t1, t0) = current-tangent p in
    let n = segment (t1, t0) |> normalize |> point-float-to-length in
    let a = rotate-point (Float.pi *. 0.5) (n *'. (r /' 1cm)) in
    let c = shift-point t1 a in
    arc-with-around-in-radians c t p

  let arc-aside-in-degrees c t p =
    arc-aside-in-radians c (degrees-to-radians t) p

  let arc-aside c t = match t with
  | Radians t -> arc-aside-in-radians c t
  | Degrees t -> arc-aside-in-degrees c t

  let intersection-point-of s0 s1 =
    open Float in
    let (s, sb) = s0 in
    let (e, eb) = s1 in
    let vs = s -'' sb |> point-length-to-float in
    let ve = e -'' eb |> point-length-to-float in
    let v = e -'' s |> point-length-to-float in
    let c = cross-product vs ve in
    if c == 0.0
    then None
    else
      let el = cross-product v vs /. cross-product vs ve in
      Some (e +'' ((ve |> point-float-to-length) *'. el))

  let is-same-polarity (s, sb) (e, eb) = open Float in
    let d = dot-product-normalized-lines-of (sb, s) (e, s) in
    0.0 < d
  let is-endpoints-aligned-orthogonally (s, sb) (e, eb) = open Float in
    let d = dot-product-normalized-lines-of (sb, s) (e, s) in
    is-zero d
  let is-on-same-line (s, sb) (e, eb) = open Float in
    let de = dot-product-normalized-lines-of (sb, s) (e, s) in
    let deb = dot-product-normalized-lines-of (sb, s) (eb, s) in
    if abs de == 1.0 && abs deb == 1.0 then true else false


  % let arc-to-for f t p =
  %   open Float in
  %   let ts = current-tangent p in
  %   let te = (t, f) in
  %   let (s, sb) = ts in
  %   let (e, eb) = te in
  %   if is-zero-distance-between s e then p else
  %   let desired-endpoints-of-arc =
  %     match intersection-point-of ts te with
  %     | None -> % when parallel
  %       if is-on-same-line ts te then p |> line-to e else
  %       if ! is-same-polarity ts te then p |> line-to e else
  %       if ! is-endpoints-aligned-orthogonally ts te then p |> line-to e else
  %     | Some i ->
  %       let is = (s, i) in
  %       let ie = (e, i) in
  %       let longer = max is ie in
  %       let shorter = min is ie in
  %         match polarity-of-float d with
  %         | Zero -> (p, s, e)
  %         | Negative ->
  %           let x = intersection-point-of (s, sb) (e, rotate-point-around e (Float.pi *. 0.5) eb) |> Option.unwrap-or s in
  %           (p |> line-to x, x, e)
  %         | Positive ->
  %           let x = intersection-point-of (e, eb) (s, rotate-point-around s (Float.pi *. 0.5) sb) |> Option.unwrap-or e in
  %           (p, s, x)
  %   in
  %   let (p, s, e) = desired-endpoints-of-arc in
  %   p |> arc-to-around 

  let trace t s e p =
    t s e p

  let draw-text-center-at p ib =
    let (tw, th, td) = get-natural-metrics ib in
    let o = (0cm -' (tw *' 0.5), 0cm -' (th *' 0.5)) in
    draw-text (shift-point p o) ib

  let translate-footage p f =
    f |> Fn.compose (shift-graphics p)

  let-inline ctx \stylo (width, height, depth) fs =
    inline-graphics width height depth (fun (x, y) -> (
      let offset = translate-footage (x, y) in
      fs |> List.map offset |> List.apply ctx
    ))

  let solid p = fun ctx -> stroke 0.75pt Color.black p
  let label-at p it = fun ctx -> read-inline ctx it |> draw-text-center-at p


end